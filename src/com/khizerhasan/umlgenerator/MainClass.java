package com.khizerhasan.umlgenerator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import japa.parser.JavaParser;
import japa.parser.ast.CompilationUnit;
import japa.parser.ast.body.ClassOrInterfaceDeclaration;
import japa.parser.ast.body.ConstructorDeclaration;
import japa.parser.ast.body.FieldDeclaration;
import japa.parser.ast.body.MethodDeclaration;
import japa.parser.ast.body.ModifierSet;
import japa.parser.ast.body.Parameter;
import japa.parser.ast.body.VariableDeclarator;
import japa.parser.ast.type.ClassOrInterfaceType;
import japa.parser.ast.visitor.VoidVisitorAdapter;
import net.sourceforge.plantuml.SourceStringReader;



public class MainClass {
	
	static List<String> classList = new ArrayList<String>();
	static List<String> classVarList = new ArrayList<String>();	
	static List<String> varTypeList = new ArrayList<String>();
	static List<String> InterfaceList = new ArrayList<String>();
	static List<String> AssociationList = new ArrayList<String>();
	static List<String> collectionList = new ArrayList<String>();
	static List<String> constructorList = new ArrayList<String>();
	static List<String> methodsList = new ArrayList<String>();
	static List<String> methodList = new ArrayList<String>();
	static List<String> variableList = new ArrayList<String>();
	static List<ClassOrInterfaceType>	clsExtndList = new ArrayList<ClassOrInterfaceType>();
	static List<ClassOrInterfaceType>	clsImplmntList = new ArrayList<ClassOrInterfaceType>();
	
	static String relationshipFlag;
	
	static StringBuilder sb = new StringBuilder();
	static StringBuilder relationships = new StringBuilder();
	static StringBuilder associations = new StringBuilder();
	
    public static void main(String[] args) throws Exception {
    	
        // creates an input stream for the files to be parsed
    	String path = args[0];
    	File folder = new File(path);
    	File[] files = folder.listFiles();	
    	
		for (int i = 0; i < files.length; i++) {
			File f = files[i];
			if (f.isFile() && f.getName().endsWith(".java")) {
				FileInputStream in = new FileInputStream(f);
			      
		        CompilationUnit cu;
		      
		        try {
		            // parse the file
		            cu = JavaParser.parse(in);
		        } finally {
		            in.close();
		        }
		        new ClassVisitor().visit(cu, null);
			}
		}
    	
    	
       markAssocations();
       markMultiplicityOnAssociation();
       getterSetter();
       System.out.println("Input for PlatUML\n");
       System.out.print(sb.toString());
       System.out.print(relationships.toString());
       System.out.println(associations.toString());
       
       //Output an Image output is in the same directory as the input
       OutputStream png = null;
       
       //
       png = new FileOutputStream(args[1]+".png");
       String source = "@startuml\n";
       source += sb.toString() + relationships.toString() + associations.toString();
       source += "@enduml\n";
       SourceStringReader reader = new SourceStringReader(source);
       // Write the first image to "png"
       String desc = reader.generateImage(png);
       // Return a null string if no generation
       png.close();
       
       System.out.println("png image generated by PlantUML");
    }
    
    
  //method to implement Getter Setter logic
   private static void getterSetter() {
		int i=0; int j=0;
		int getter_index = 0;
		int setter_index = 0;
		
		for(i=0;i<variableList.size();i++){
			getter_index = methodsList.indexOf("get"+variableList.get(i));
			setter_index = methodsList.indexOf("set"+variableList.get(i));
				
			if( getter_index!= -1 && setter_index!= -1  ){
			
				String[] tokensVar = variableList.get(i).split(":");
				int index = sb.indexOf(tokensVar[0]);
				sb.replace(index-1, index, "+");
					
				String[] tokensGetMeth = methodList.get(getter_index).split(":");
				String[] tokensSetMeth = methodList.get(setter_index).split(":");
				
				int getStartIndex = sb.indexOf(tokensGetMeth[0]);
				int getEndIndex = sb.indexOf("\n",getStartIndex );
				sb.delete(getStartIndex-1,getEndIndex+1);
				
				int setStartIndex = sb.indexOf(tokensSetMeth[0]);
				int setEndIndex = sb.indexOf("\n",setStartIndex );
				sb.delete(setStartIndex-1,setEndIndex+1);
				
			}	
		}
	}


   //method to mark multiplicity on associations
	private static void markMultiplicityOnAssociation() {
    	for (Iterator<String> iterator = collectionList.iterator(); iterator.hasNext();) {
			String cls = iterator.next();
			String[] tokensVal = cls.split(":");
			if(collectionList.contains(tokensVal[1]+tokensVal[0])){
				if(InterfaceList.contains(tokensVal[1]))
					associations.append("");
				else if(InterfaceList.contains(tokensVal[0]))
					associations.append("");
				else
					associations.append(tokensVal[0]+"]\"*\" -- \"*\"["+tokensVal[1]+"\n");
				
				String toDel = tokensVal[0]+" -- "+tokensVal[1]+"\n";
				int start = associations.indexOf(toDel);
				if (start!= -1)
				associations.replace(start, start + toDel.length(), "");
			}
			else{
				
				if(InterfaceList.contains(tokensVal[1]))
					associations.append("");
					else if(InterfaceList.contains(tokensVal[0]))
					associations.append("");
				else
					associations.append(tokensVal[0]+"\"*\" -- \"1\""+tokensVal[1]+"\n");
				
				String toDel = tokensVal[0]+" -- "+tokensVal[1]+"\n";
				int start = associations.indexOf(toDel);
				if (start!= -1)
				associations.replace(start, start + toDel.length(), "");
			}
			
    	}
	}
	
	//method to mark assoications
	private static void markAssocations() {
    	
    	for (Iterator<String> iterator = varTypeList.iterator(); iterator.hasNext();) {
			String matching = iterator.next();
			int index = classList.indexOf(matching);
			if(index!= -1){
				List<Integer> indexs =new ArrayList<Integer>();
				for (int p = 0; p < varTypeList.size(); p++) {
				    if((varTypeList.get(p))== matching) {
				        indexs.add(p);
				    }
				}
				for(int p = 0;p<indexs.size();p++)
				{
					String match1 = varTypeList.get(indexs.get(p));
					String match2 = classVarList.get(indexs.get(p));
					String association = "";
					
					//logic for uses (when a method parameter is of Interface type in a class)
					if(InterfaceList.contains(match1)&&!InterfaceList.contains(match2)){
						association = match2+"\"uses\" -.-> "+match1+"\n";
					}
					if(!InterfaceList.contains(match1)&&InterfaceList.contains(match2)){
						association = "";
					}
					if(InterfaceList.contains(match1)&&InterfaceList.contains(match2)){
						association = "";
					}
					if(!InterfaceList.contains(match1)&&!InterfaceList.contains(match2)){
						//logic for 1-1 association.
						if(AssociationList.contains(match1+":"+match2))
						{
							String temp = match1+" -- "+match2+"\n";
							int i = associations.indexOf(temp);
							if(i!=-1)
							{
								associations.replace(i,i+temp.length(),match1+"\"1\" -- \"1\""+match2+"\n");
							}
							
						}
						else{
							AssociationList.add(match2+":"+match1);
							if(constructorList.contains(match2+":"+match1)){
							association = "";
							}
							else{
							association = match2+" -- "+match1+"\n";
							}
						}
					}
					
					//logic for checking if the association already exist
					if(associations.indexOf(association)== -1){
						associations.append(association);
					}
				}
			}
		}
    	
	}

	
	
	//Class responsible for visiting various methods
    private static class MethodVisitor extends VoidVisitorAdapter {
    	
    	//Constructor Visitor
    	@Override
        public void visit(ConstructorDeclaration n, Object arg) {
    		
    		//Getting the modifiers of the Constructor
        	int mod = n.getModifiers();
        	if(ModifierSet.isPrivate(mod)){
            	sb.append("-");
            }
        	if(ModifierSet.isProtected(mod)){
            	sb.append("#");
            }
        	if(ModifierSet.isPublic(mod)){
        		
            	sb.append("+");
            }
        	
        	//Constructor Name
        	sb.append(n.getName());
        	
        	
        	
        	//Constructor Parameters
        	List<Parameter> parList = n.getParameters();
        	if(parList!=null){
        	sb.append("(");
        		for (Iterator<Parameter> iterator = parList.iterator(); iterator.hasNext();) {
        			Parameter parameter = iterator.next();
        			sb.append(parameter.getId());
				
        			String type = parameter.getType().toString();
        			sb.append(" : "+type);
				
        			// Association logic
        			classVarList.add(relationshipFlag);
        			varTypeList.add(parameter.getType().toString());
        			constructorList.add(relationshipFlag+":"+parameter.getType().toString());
				
        		}
        	sb.append(")");
        	}
        	else{
        		sb.append("()");
        	}
        	sb.append("\n");
    	}

    	
    	//Method Visitor
    	@Override
        public void visit(MethodDeclaration n, Object arg) {

        	int mod = n.getModifiers();
        	if(ModifierSet.isPrivate(mod)){
            	sb.append("-");
            }
        	if(ModifierSet.isProtected(mod)){
            	sb.append("#");
            }
        	if(ModifierSet.isPublic(mod)){
            	sb.append("+");
            }
        	
        	//Method Name
        	sb.append(n.getName());
        	
        	//Method Parameters
        	List<Parameter> parList = n.getParameters();
        	if(parList!=null){
        	sb.append("(");
        	for (Iterator<Parameter> iterator = parList.iterator(); iterator.hasNext();) 
        		{
					Parameter parameter = iterator.next();
					sb.append(parameter.getId());
					String type = parameter.getType().toString();
					sb.append(" : "+type);
				
					//This part is for Association Logic
	        		classVarList.add(relationshipFlag);
					varTypeList.add(parameter.getType().toString());
				
				}
        	sb.append(")");
        	}
        	else{
        		sb.append("()");
        	}
        	//Method ReturnType
        	sb.append(" : "+ n.getType()+"\n");
        	methodsList.add(n.getName().toLowerCase()+":"+relationshipFlag);
        	methodList.add(n.getName()+":"+relationshipFlag);
    	}
    }
    
    //this class is for Visiting the classes
    private static class ClassVisitor extends VoidVisitorAdapter {

        @Override
        public void visit(ClassOrInterfaceDeclaration n, Object arg) {
      
        	String className = n.getName();
      
        	//Code for Extends Part
        	clsExtndList = n.getExtends();
        	if(clsExtndList!=null)
        	for (int i= 0 ; i< clsExtndList.size(); i++){
        		relationships.append(clsExtndList.get(i).getName()+" ^- "+className+"\n");

        	}
        	
        	
        	//Code for Implements Part
        	clsImplmntList = n.getImplements();
        	if(clsImplmntList!=null)
        	for (int i= 0 ; i< clsImplmntList.size(); i++){
        		//sb.append("["+className+" Implements "+clsImplmntList.get(i).getName());
        		relationships.append(clsImplmntList.get(i).getName()+" ^-.- "+className+"\n");
        		
        	}
        	
        	if(n.isInterface()){
       			InterfaceList.add(className);
       			sb.append("interface "+className+"{\n");
        	}
        	else{
        		sb.append("class "+className +"{\n");
        		
        	}
        	
        	//This Part is for Association Logic
        	classList.add(className);	
        	relationshipFlag = className;
            
        	//to list all the variables inside the class
        	new VariableVisitor().visit(n, null);
        	
        	//to list all the methods inside the class
            new MethodVisitor().visit(n, null); 
            
            
            sb.append("}\n");
        }
    }

    
    //this class is for detecting the variables
    private static class VariableVisitor extends VoidVisitorAdapter {
        @Override
        public void visit(FieldDeclaration n, Object arg) {
  
        		String type = n.getType().toString();
  
        		//Getting modifiers of the variables
        		int mod = n.getModifiers();
        		if(ModifierSet.isPrivate(mod)){
            		sb.append("-");
            	}
        		if(ModifierSet.isPublic(mod)){
            		sb.append("+");
            	}
        		
        		if(ModifierSet.isProtected(mod)){
            		//sb.append("#");
            	}
        		
        		else if(mod == 0){
        			
        			
        		}
        		
        		else{
        		
        		for (Iterator<VariableDeclarator> iterator = n.getVariables().iterator(); iterator.hasNext();) {
    				VariableDeclarator parameter = iterator.next();
    				sb.append(parameter.getId());
    				
    				variableList.add( parameter.getId().toString()+ ":" + relationshipFlag );
    				
    				String prefix = "Collection<";
    				if(type.startsWith(prefix)){
    					collectionList.add(type.substring(prefix.length(),type.length()-1)+":"+relationshipFlag);
    					sb.delete(sb.length()-(parameter.getId().toString().length())-1, sb.length());
    				}
    				else
    					
    					if(type.equalsIgnoreCase(parameter.getId().toString())){
    						sb.delete(sb.length()-(parameter.getId().toString().length())-1, sb.length());
    					}
    				
    				else
    					sb.append(" : "+type+"\n");
        			}
        		}
        		//This part is for Association Logic
        		classVarList.add(relationshipFlag);
        		varTypeList.add(n.getType().toString());
        	
        }
    } 
}

